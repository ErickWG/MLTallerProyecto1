import os
import logging
import oracledb
from contextlib import contextmanager
from datetime import datetime

logger = logging.getLogger(__name__)

# Configuración de Oracle obtenida desde variables de entorno
ORACLE_CONFIG = {
    "user": "SYSTEM",
    "password": "erick710132",
    "dsn": "localhost:1521/xe",
}

oracle_pool = None


def inicializar_oracle_pool():
    """Inicializa el pool de conexiones de Oracle"""
    global oracle_pool
    try:
        oracle_pool = oracledb.create_pool(
            user=ORACLE_CONFIG["user"],
            password=ORACLE_CONFIG["password"],
            dsn=ORACLE_CONFIG["dsn"],
            min=2,
            max=10,
            increment=1,
        )
        logger.info("Pool de conexiones Oracle inicializado")
        return True
    except Exception as e:
        logger.error(f"Error inicializando Oracle: {e}")
        return False


@contextmanager
def get_oracle_connection():
    """Context manager para obtener conexión del pool"""
    connection = oracle_pool.acquire()
    connection.encoding = "UTF-8"
    connection.nencoding = "UTF-8"
    try:
        yield connection
    finally:
        oracle_pool.release(connection)


def crear_tablas_oracle():
    """Crea las tablas necesarias en Oracle si no existen"""
    sql_scripts = [
        """
        CREATE TABLE ALERTAS_FRAUDE (
            ID_ALERTA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            FECHA_PROCESAMIENTO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FECHA_REGISTRO VARCHAR2(10),
            CODIGO_PAIS NUMBER,
            LINEA VARCHAR2(20),
            N_LLAMADAS NUMBER,
            N_MINUTOS NUMBER(10,2),
            N_DESTINOS NUMBER,
            SCORE_ANOMALIA NUMBER(10,4),
            UMBRAL NUMBER(10,4),
            TIPO_ANOMALIA VARCHAR2(50),
            CRITICIDAD VARCHAR2(20),
            TIPO_CONTEXTO VARCHAR2(50),
            RAZON_DECISION VARCHAR2(200),
            ARCHIVO_ORIGEN VARCHAR2(100),
            LOTE_PROCESAMIENTO VARCHAR2(50)
        )
        """,
        """
        CREATE TABLE LOTES_PROCESAMIENTO (
            ID_LOTE NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            TIMESTAMP_INICIO TIMESTAMP,
            TIMESTAMP_FIN TIMESTAMP,
            ARCHIVO_ENTRADA VARCHAR2(200),
            TOTAL_REGISTROS NUMBER,
            TOTAL_ANOMALIAS NUMBER,
            TASA_ANOMALIAS NUMBER(5,2),
            ARCHIVO_SALIDA VARCHAR2(200),
            ESTADO VARCHAR2(20),
            MENSAJE_ERROR VARCHAR2(500)
        )
        """,
        """
        CREATE TABLE HISTORICO_UMBRALES (
            ID_CAMBIO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            FECHA_CAMBIO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UMBRAL_ANTERIOR NUMBER(10,4),
            UMBRAL_NUEVO NUMBER(10,4),
            RAZON_CAMBIO VARCHAR2(200),
            USUARIO VARCHAR2(50)
        )
        """,
        """
        CREATE TABLE ACTUALIZACION_DIARIA_UMBRAL (
            ID_ACTUALIZACION NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            FECHA_EJECUCION TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FECHA_DATOS DATE,
            ARCHIVO_ENTRADA VARCHAR2(200),
            TOTAL_REGISTROS NUMBER,
            REGISTROS_PROCESADOS NUMBER,
            PAISES_TOTALES NUMBER,
            PAISES_NUEVOS NUMBER,
            PAISES_ACTUALIZADOS NUMBER,
            UMBRAL_ANTERIOR NUMBER(10,4),
            N_TREES_ANTERIOR NUMBER,
            PAISES_CONOCIDOS_ANTERIOR NUMBER,
            UMBRAL_NUEVO NUMBER(10,4),
            N_TREES_NUEVO NUMBER,
            PAISES_CONOCIDOS_NUEVO NUMBER,
            PAISES_CON_CAMBIO_CATEGORIA NUMBER,
            DETALLE_CAMBIOS_CATEGORIA CLOB,
            TIEMPO_PROCESAMIENTO_SEG NUMBER(10,2),
            MEMORIA_USADA_MB NUMBER(10,2),
            ESTADO VARCHAR2(20),
            MENSAJE_ERROR VARCHAR2(500),
            ARCHIVO_BACKUP_CONFIG VARCHAR2(200),
            LLAMADAS_PROMEDIO_GLOBAL NUMBER(10,2),
            MINUTOS_PROMEDIO_GLOBAL NUMBER(10,2),
            DESTINOS_PROMEDIO_GLOBAL NUMBER(10,2),
            UMBRAL_MINUTOS_EXTREMOS NUMBER(10,2),
            PESO_SPRAY_RATIO NUMBER(10,2),
            OBSERVACIONES VARCHAR2(1000)
        )
        """,
        # Índices
        "CREATE INDEX IDX_ALERTAS_FECHA ON ALERTAS_FRAUDE(FECHA_PROCESAMIENTO)",
        "CREATE INDEX IDX_ALERTAS_PAIS ON ALERTAS_FRAUDE(CODIGO_PAIS)",
        "CREATE INDEX IDX_ALERTAS_LINEA ON ALERTAS_FRAUDE(LINEA)",
        "CREATE INDEX IDX_ALERTAS_TIPO ON ALERTAS_FRAUDE(TIPO_ANOMALIA)",
        "CREATE INDEX IDX_APRENDIZAJE_FECHA ON ACTUALIZACION_DIARIA_UMBRAL(FECHA_EJECUCION)",
        "CREATE INDEX IDX_APRENDIZAJE_ESTADO ON ACTUALIZACION_DIARIA_UMBRAL(ESTADO)",
        """
        CREATE TABLE USERS (
            ID_USER NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            USERNAME VARCHAR2(50) UNIQUE NOT NULL,
            PASSWORD_HASH VARCHAR2(128) NOT NULL,
            ROLE VARCHAR2(20) DEFAULT 'user' NOT NULL
        )
        """,
        "CREATE INDEX IDX_USERS_USERNAME ON USERS(USERNAME)",
        "ALTER TABLE USERS ADD (ROLE VARCHAR2(20) DEFAULT 'user' NOT NULL)"
    ]

    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        for script in sql_scripts:
            try:
                cursor.execute(script)
                logger.info("Tabla/Índice creado exitosamente")
            except oracledb.DatabaseError as e:
                error, = e.args
                if error.code in (955, 1430):
                    logger.info("Tabla o columna ya existe, continuando...")
                else:
                    logger.error(f"Error creando tabla: {e}")
                    raise
        conn.commit()
        logger.info("Todas las tablas creadas/verificadas exitosamente")


def obtener_usuario(username):
    """Obtiene un usuario por su nombre de usuario"""
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(
            "SELECT ID_USER, USERNAME, PASSWORD_HASH, ROLE FROM USERS WHERE USERNAME = :1",
            [username],
        )
        row = cursor.fetchone()
        if row:
            return {
                "id": row[0],
                "username": row[1],
                "password_hash": row[2],
                "role": row[3],
            }
        return None


def crear_usuario(username, password_hash, role="user"):
    """Crea un nuevo usuario"""
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO USERS (USERNAME, PASSWORD_HASH, ROLE) VALUES (:1, :2, :3)",
            [username, password_hash, role],
        )
        conn.commit()


def guardar_anomalias_oracle(anomalias_df, archivo_origen, lote_id):
    """Guarda las anomalías detectadas en Oracle"""
    if anomalias_df.empty:
        return
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        datos_insertar = []
        for _, row in anomalias_df.iterrows():
            datos_insertar.append(
                (
                    row['FECHA'],
                    int(row['CODIGODEPAIS']),
                    row['LINEA'],
                    int(row['N_LLAMADAS']),
                    float(row['N_MINUTOS']),
                    int(row['N_DESTINOS']),
                    float(row['score_anomalia']),
                    float(row['umbral']),
                    row['tipo_anomalia'],
                    row['criticidad'],
                    row['tipo_contexto'],
                    row['razon_decision'],
                    archivo_origen,
                    lote_id,
                )
            )
        insert_sql = """
            INSERT INTO ALERTAS_FRAUDE (
                FECHA_REGISTRO, CODIGO_PAIS, LINEA, N_LLAMADAS, N_MINUTOS,
                N_DESTINOS, SCORE_ANOMALIA, UMBRAL, TIPO_ANOMALIA, CRITICIDAD,
                TIPO_CONTEXTO, RAZON_DECISION, ARCHIVO_ORIGEN, LOTE_PROCESAMIENTO
            ) VALUES (:1, :2, :3, :4, :5, :6, :7, :8, :9, :10, :11, :12, :13, :14)
        """
        cursor.executemany(insert_sql, datos_insertar)
        conn.commit()
        logger.info(f"Se guardaron {len(datos_insertar)} anomalías en Oracle")


def registrar_lote_procesamiento(
    archivo_entrada,
    total_registros=0,  # Cambiar a 0 por defecto
    total_anomalias=0,  # Cambiar a 0 por defecto  
    tasa_anomalias=0,   # Cambiar a 0 por defecto
    archivo_salida=None,
    estado="EN_PROCESO",  # CAMBIO: Empezar como EN_PROCESO
):
    """Registra información del lote procesado"""
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        insert_sql = """
            INSERT INTO LOTES_PROCESAMIENTO (
                TIMESTAMP_INICIO, TIMESTAMP_FIN, ARCHIVO_ENTRADA, TOTAL_REGISTROS,
                TOTAL_ANOMALIAS, TASA_ANOMALIAS, ARCHIVO_SALIDA, ESTADO
            ) VALUES (
                :1, :2, :3, :4, :5, :6, :7, :8
            ) RETURNING ID_LOTE INTO :id_lote
        """
        id_lote = cursor.var(oracledb.NUMBER)
        cursor.execute(
            insert_sql,
            [
                datetime.now(),
                None,  # CAMBIO: TIMESTAMP_FIN debe ser None al inicio
                archivo_entrada,
                total_registros,
                total_anomalias,
                tasa_anomalias,
                archivo_salida,
                estado,
                id_lote,
            ],
        )
        conn.commit()
        return id_lote.getvalue()[0]
    
def actualizar_lote_procesamiento(
    lote_id,
    total_registros=None,
    total_anomalias=None,
    tasa_anomalias=None,
    archivo_salida=None,
    estado=None,
    mensaje_error=None
):
    """Actualiza información del lote procesado"""
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        
        # Construir UPDATE dinámicamente
        campos = []
        valores = []
        
        if total_registros is not None:
            campos.append("TOTAL_REGISTROS = :reg")
            valores.append(("reg", total_registros))
            
        if total_anomalias is not None:
            campos.append("TOTAL_ANOMALIAS = :anom")
            valores.append(("anom", total_anomalias))
            
        if tasa_anomalias is not None:
            campos.append("TASA_ANOMALIAS = :tasa")
            valores.append(("tasa", tasa_anomalias))
            
        if archivo_salida is not None:
            campos.append("ARCHIVO_SALIDA = :archivo")
            valores.append(("archivo", archivo_salida))
            
        if estado is not None:
            campos.append("ESTADO = :estado")
            valores.append(("estado", estado))
            
        if mensaje_error is not None:
            campos.append("MENSAJE_ERROR = :error")
            valores.append(("error", mensaje_error))
            
        # Siempre actualizar timestamp_fin si se pasa estado final
        if estado in ['COMPLETADO', 'ERROR']:
            campos.append("TIMESTAMP_FIN = :fin")
            valores.append(("fin", datetime.now()))
        
        if campos:
            update_sql = f"""
                UPDATE LOTES_PROCESAMIENTO 
                SET {', '.join(campos)}
                WHERE ID_LOTE = :lote_id
            """
            
            # Crear diccionario de parámetros
            params = {nombre: valor for nombre, valor in valores}
            params['lote_id'] = lote_id
            
            cursor.execute(update_sql, params)
            conn.commit()
            logger.info(f"Lote {lote_id} actualizado con estado: {estado}")

def actualizar_progreso_actualizacion_diaria(id_actualizacion, registros_procesados, progreso_porcentaje=None):
    """Actualiza el progreso de la actualización diaria en tiempo real"""
    with get_oracle_connection() as conn:
        cursor = conn.cursor()
        
        if progreso_porcentaje is not None:
            cursor.execute("""
                UPDATE ACTUALIZACION_DIARIA_UMBRAL 
                SET REGISTROS_PROCESADOS = :1,
                    OBSERVACIONES = :2
                WHERE ID_ACTUALIZACION = :3
            """, [
                registros_procesados,
                f"Progreso: {progreso_porcentaje:.1f}% - {registros_procesados} registros procesados",
                id_actualizacion
            ])
        else:
            cursor.execute("""
                UPDATE ACTUALIZACION_DIARIA_UMBRAL 
                SET REGISTROS_PROCESADOS = :1
                WHERE ID_ACTUALIZACION = :2
            """, [registros_procesados, id_actualizacion])
        
        conn.commit()